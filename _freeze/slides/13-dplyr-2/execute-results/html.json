{
  "hash": "5c6cbdc2d7902c61ec06b603262346e3",
  "result": {
    "markdown": "---\ntitle: \"Data Wrangling - two data frames ðŸ› \"\nsubtitle: \"MATH/COSC 3570 Introduction to Data Science\"\nauthor: \"Dr. Cheng-Han Yu <br> Department of Mathematical and Statistical Sciences <br> Marquette University\"\n# date: \"December 23 2023\"\n# macros: _macros.tex # import a list of TeX/LaTeX definitions\nformat: \n  revealjs:\n    #     - \"macros.tex\"\n    html-math-method:\n      method: mathjax\n      url: \"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"\n    # include-in-header:\n    highlight-style: arrow\n    code-block-bg: true\n    self-contained: false\n    slide-number: c/t\n    incremental: false\n    width: 1800\n    height: 1000\n    margin: 0.05\n    logo: \"https://upload.wikimedia.org/wikipedia/commons/e/e8/Marquette_Golden_Eagles_logo.svg\"\n    footer: \"[math3570-s24.github.io/website](https://math3570-s24.github.io/website/)\"\n    theme: [\"simple\", \"slides.scss\"]\n    multiplex: true\n    code-link: true\n    fig-cap-location: bottom\n    fig-align: center\n    transition: none ## fade slide convex concave zoom\n    title-slide-attributes:\n      data-background-color: \"#447099\"\n      # data-background-image: images/paper-texture.jpg\n      # data-background-size: cover\n      # data-background-color: \"#698ED5\"\neditor: source\nexecute:\n  freeze: true\n  echo: true\n---\n\n\n#  {visibility=\"hidden\"}\n\n\\def\\bx{\\mathbf{x}}\n\\def\\bg{\\mathbf{g}}\n\\def\\bw{\\mathbf{w}}\n\\def\\bbeta{\\boldsymbol \\beta}\n\\def\\bX{\\mathbf{X}}\n\\def\\by{\\mathbf{y}}\n\\def\\bH{\\mathbf{H}}\n\\def\\bI{\\mathbf{I}}\n\\def\\bS{\\mathbf{S}}\n\\def\\bW{\\mathbf{W}}\n\\def\\T{\\text{T}}\n\\def\\cov{\\mathrm{Cov}}\n\\def\\cor{\\mathrm{Corr}}\n\\def\\var{\\mathrm{Var}}\n\\def\\E{\\mathrm{E}}\n\\def\\bmu{\\boldsymbol \\mu}\n\\DeclareMathOperator*{\\argmin}{arg\\,min}\n\\def\\Trace{\\text{Trace}}\n\n\n\n\n\n\n\n# {background-color=\"#A7D5E8\" background-image=\"https://raw.githubusercontent.com/rstudio/hex-stickers/master/PNG/dplyr.png\" background-size=\"30%\" background-position=\"90% 50%\"}\n\n::: {.left}\n<h1> Joining data frames </h1>\n:::\n\n## Joining data frames\n\n- **Have** multiple data frames\n\n- **Want** to bring them together\n\n- [SQL](https://www.w3schools.com/sql/sql_join.asp)-like functions\n    - `left_join(x, y)`\n    - `right_join(x, y)`\n    - `full_join(x, y)`\n    - `inner_join(x, y)`\n    - `semi_join(x, y)`\n    - `anti_join(x, y)`\n\n::: notes\n<!-- # ```{r eval=FALSE} -->\n<!-- # #| eval: false -->\n<!-- # something_join(x, y)   -->\n<!-- # ``` -->\n- OK, back to dplyr. Here the idea is that we have two or more data frames, and we want to bring them together as one single combined data set.\n- How? we are gonna use dplyr functions with name something_join(x, y).\n- These functions borrow the idea of SQL for relational database management. They are similar to the join functions of SQL.\n- And so we can do something that SQL usually does in R, and it's probably easier because we don't need to use R and SQL back and forth, and integrate data manipulation and analysis together.\n- In particular, we are gonna go through the following 6 join functions.\n- Here x and y are data frames. OK.\n:::\n\n## Setup\n\nData sets `x` and `y` share the same variable `id`.\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- tibble(\n    id = c(1, 2, 3),\n    var_x = c(\"x1\", \"x2\", \"x3\")\n    )\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 Ã— 2\n     id var_x\n  <dbl> <chr>\n1     1 x1   \n2     2 x2   \n3     3 x3   \n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ny <- tibble(\n    id = c(1, 2, 4),\n    var_y = c(\"y1\", \"y2\", \"y4\")\n    )\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 Ã— 2\n     id var_y\n  <dbl> <chr>\n1     1 y1   \n2     2 y2   \n3     4 y4   \n```\n:::\n:::\n\n:::\n::::\n\n\n::: notes\n- I am going to use these two data frames as an illustration of join functions.\n- data frame x has variable id and var_x\n- data frame y has variable again id and but another variable var_y.\n- Data frame `x` and `y` have the common variable `id`, so it's quite reasonable to merge the two data sets together by the common variable `id`. But x has id 1, 2, 3 and y has id 1, 2, 4. And so there are many different ways to combine the two.\n- You can think id is marquette ID, and var_x stores GPA and var_y stores say students' height. And we are gonna combine the two data sets into one student personal information data set.\n:::\n\n## `left_join(x, y)`: all rows from x\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/13-dplyr-2/left-join.gif){fig-align='center' width=100% style=\"background-color: #FDF6E3\"}\n:::\n:::\n\n:::\n\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## by = keys\nleft_join(x, y, by = \"id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 Ã— 3\n     id var_x var_y\n  <dbl> <chr> <chr>\n1     1 x1    y1   \n2     2 x2    y2   \n3     3 x3    <NA> \n```\n:::\n:::\n\n\n- `NA` is added to the `id` not appearing in `y`.  \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/13-dplyr-2/left_join_venn.png){fig-align='center' width=100%}\n:::\n:::\n\n:::\n::::\n\n::: notes\n- OK first left_join. Look at this gif. \n- The idea is that left_join(x, y) keeps all the rows or observations from x, and keep all the variables in x and y, including id, var_x and var_y.\n- The variables used to connect two data tables are called **keys**, and we use by argument to tell dplyr which variable is the key\n- By default, the function uses all variables that appear in both tables as keys. So here, the default key is also \"id\" because \"id\" is the only variable that appears in both data sets.\n- The resulting data frame is shown here. The left join function basically keeps the entire data set x, and attaches the data set y to x with \"id\" in x.\n- Because y doesn't have id 3, its value of var_y is a missing value NA.\n- We can use the venn diagram to visualize the idea of joining tables. And basically, the main data set is A or x. We keep everything of A, and we add stuff of B or y for observations that are in A or x only.\n:::\n\n\n\n## `left_join()` Example\n\n::::: {.panel-tabset}\n\n\n## Left join\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell layout-align=\"center\" highlight.output='[5,7]'}\n\n```{.r .cell-code}\npop_x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       state population\n1    Alabama    4779736\n2     Alaska     710231\n3    Arizona    6392017\n4   Arkansas    2915918\n5 California   37253956\n6   Colorado    5029196\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\" highlight.output='[5,7]'}\n\n```{.r .cell-code}\nelec_vote_y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        state elec_vote\n1  California        55\n2     Arizona        11\n3     Alabama         9\n4 Connecticut         7\n5      Alaska         3\n6    Delaware         3\n```\n:::\n:::\n\n:::\n\n\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\" highlight.output='[5,7]'}\n\n```{.r .cell-code}\npop_x |> \n    left_join(elec_vote_y) #<<\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       state population elec_vote\n1    Alabama    4779736         9\n2     Alaska     710231         3\n3    Arizona    6392017        11\n4   Arkansas    2915918        NA\n5 California   37253956        55\n6   Colorado    5029196        NA\n```\n:::\n:::\n\n- `Connecticut` and `Delaware` in `elec_vote_y` will not be shown in the left-joined data because they are not in `pop_x`.\n:::\n::::\n\n\n## Code for generating the data sets\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(dslabs)\npop_x <- murders |> \n    slice(1:6) |>\n    select(state, population)\n\nelec_vote_y <- results_us_election_2016 |> \n    filter(state %in% c(\"Alabama\", \"Alaska\", \"Arizona\", \n                        \"California\", \"Connecticut\", \"Delaware\")) |> \n    select(state, electoral_votes) |> \n    rename(elec_vote = electoral_votes)\n```\n:::\n\n\n:::::\n\n::: notes\n- Let's see an example. Here we have two data sets, pop_x and elec_vote_y.\n- The left_join() function uses the common variable \"state\" to combine the two data sets.\n- And the result of left joining will be that we keep the entire data set pop_x, and attach the variable elec_vote to the data. \n- If there is no such state or observation in y, its corresponding value of elec_vote is NA.\n:::\n\n\n## `right_join(x, y)`: all rows from y\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/13-dplyr-2/right-join.gif){fig-align='center' width=100% style=\"background-color: #FDF6E3\"}\n:::\n:::\n\n:::\n\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nright_join(x, y)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(id)`\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 Ã— 3\n     id var_x var_y\n  <dbl> <chr> <chr>\n1     1 x1    y1   \n2     2 x2    y2   \n3     4 <NA>  y4   \n```\n:::\n:::\n\n\n- `NA` is in the column coming from `x`.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/13-dplyr-2/right_join_venn.png){fig-align='center' width=100%}\n:::\n:::\n\n:::\n::::\n\n::: notes\n- OK. If you get the idea of left_join, you =should be able to guess what right_join() function is doing.\n- Basically right_join(x, y) keeps all the rows or observations from y, and second data set, and again keep all the variablesin both x and y, including id, var_x and var_y.\n- For any observation that is not in x, its corresponding value of var_x becomes a missing value NA.\n- So here because x does not have id 4, its value of var_x is NA.\n- In the venn diagram, the main data set is B or y. We keep everything of B, and we add stuff of A or x for observations that are in B or y only.\n:::\n\n\n\n## `right_join()` Example\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\" highlight.output='[5,7]'}\n\n```{.r .cell-code}\npop_x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       state population\n1    Alabama    4779736\n2     Alaska     710231\n3    Arizona    6392017\n4   Arkansas    2915918\n5 California   37253956\n6   Colorado    5029196\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nelec_vote_y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        state elec_vote\n1  California        55\n2     Arizona        11\n3     Alabama         9\n4 Connecticut         7\n5      Alaska         3\n6    Delaware         3\n```\n:::\n:::\n\n:::\n\n\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npop_x |> \n    right_join(elec_vote_y) #<<\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        state population elec_vote\n1     Alabama    4779736         9\n2      Alaska     710231         3\n3     Arizona    6392017        11\n4  California   37253956        55\n5 Connecticut         NA         7\n6    Delaware         NA         3\n```\n:::\n:::\n\n- `Arkansas` and `Colorado` in `pop_x` will not be shown in the right-joined data because they are not in `elec_vote_y`.\n:::\n::::\n\n::: notes\n- Back to the example, if we are doing right-join, we keep the entire data set elec_vote_y, and attach the variable population of pop_x to the data. \n- If there is no such state or observation in x, its corresponding value of population is NA.\n- Since x does not have Connecticut and Delaware, their population is NA.\n- `Arkansas` and `Colorado` in `pop_x` will not be shown in the right-joined data because they are not in `elec_vote_y`.\n:::\n\n## `full_join(x, y)`: all rows from both x and y\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/13-dplyr-2/full-join.gif){fig-align='center' width=100% style=\"background-color: #FDF6E3\"}\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfull_join(x, y)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(id)`\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 Ã— 3\n     id var_x var_y\n  <dbl> <chr> <chr>\n1     1 x1    y1   \n2     2 x2    y2   \n3     3 x3    <NA> \n4     4 <NA>  y4   \n```\n:::\n:::\n\n- Keep *all the rows* and fill the missing parts with `NA`s.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/13-dplyr-2/full_join_venn.png){fig-align='center' width=100%}\n:::\n:::\n\n:::\n::::\n\n::: notes\n- The next is full_join(). full_join() preserves all the rows or observations either in x or in y or in both x and y.\n- In x, we have 1, 2, 3, and in y, we have 1, 2, 4. So the resulting full-joined data frame will have observations 1, 2, 3, 4, and fill the missing parts with NAs.\n- x does not have id 4, so its var_x is NA. y does not have id 3, so its var_y is NA\n:::\n\n\n\n## `full_join()`  Example\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npop_x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       state population\n1    Alabama    4779736\n2     Alaska     710231\n3    Arizona    6392017\n4   Arkansas    2915918\n5 California   37253956\n6   Colorado    5029196\n```\n:::\n\n```{.r .cell-code}\nelec_vote_y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        state elec_vote\n1  California        55\n2     Arizona        11\n3     Alabama         9\n4 Connecticut         7\n5      Alaska         3\n6    Delaware         3\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npop_x |> \n    full_join(elec_vote_y) #<<\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        state population elec_vote\n1     Alabama    4779736         9\n2      Alaska     710231         3\n3     Arizona    6392017        11\n4    Arkansas    2915918        NA\n5  California   37253956        55\n6    Colorado    5029196        NA\n7 Connecticut         NA         7\n8    Delaware         NA         3\n```\n:::\n:::\n\n- `full_join()` takes the union of observations of `x` and `y`, so it produces the data set with the most rows.\n:::\n::::\n\n::: notes\n- In this example, the full-joined data set will contain observations either in x or in y or in both x and y.\n- Because Arkansas and Colorado are not in elec_vote_y, their elec_vote value is NA\n- Because Connecticut and Delaware are not in pop_x, their population value is NA\n- full_join() takes the union of x and y, so it produces the data set with the most rows.\n:::\n\n\n## `inner_join(x, y)`: only rows w/ keys in both x and y\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/13-dplyr-2/inner-join.gif){fig-align='center' width=100% style=\"background-color: #FDF6E3\"}\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ninner_join(x, y)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(id)`\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 Ã— 3\n     id var_x var_y\n  <dbl> <chr> <chr>\n1     1 x1    y1   \n2     2 x2    y2   \n```\n:::\n:::\n\n- Keep only the rows that have information in both tables.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/13-dplyr-2/inner_join_venn.png){fig-align='center' width=100%}\n:::\n:::\n\n:::\n::::\n\n::: notes\n- OK inner_join(). inner_join() preserves only rows with keys or id here in both x and y.\n- And we know id 1 and id 2 are in both x and y, so these two observations are preserved.\n- id 3 is in x, but not in y, id 4 is in y, but not in x, so both are not included in the data.\n- Because we are taking intersection of the rows of x and y, we will get the fewest rows when inner_join() is used. \n:::\n\n\n## `inner_join()`  Example\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npop_x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       state population\n1    Alabama    4779736\n2     Alaska     710231\n3    Arizona    6392017\n4   Arkansas    2915918\n5 California   37253956\n6   Colorado    5029196\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nelec_vote_y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        state elec_vote\n1  California        55\n2     Arizona        11\n3     Alabama         9\n4 Connecticut         7\n5      Alaska         3\n6    Delaware         3\n```\n:::\n:::\n\n:::\n\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npop_x |> \n    inner_join(elec_vote_y) #<<\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       state population elec_vote\n1    Alabama    4779736         9\n2     Alaska     710231         3\n3    Arizona    6392017        11\n4 California   37253956        55\n```\n:::\n:::\n\n:::\n::::\n\n::: notes\n- In this example, there are 4 states in both x and y, Alabama, Alaska, Arizona, and California.\n- The inner-joined data set only keep the 4 states data.\n:::\n\n\n\n## `semi_join(x, y)`: inner_join(x, y) with columns of x  {visibility=\"hidden\"}\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/13-dplyr-2/semi-join.gif){fig-align='center' width=100% style=\"background-color: #FDF6E3\"}\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsemi_join(x, y)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(id)`\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 Ã— 2\n     id var_x\n  <dbl> <chr>\n1     1 x1   \n2     2 x2   \n```\n:::\n:::\n\n- Keep the part of first table for which we have information in the second.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/13-dplyr-2/semi_join_venn.png){fig-align='center' width=100%}\n:::\n:::\n\n:::\n::::\n\n\n::: notes\n- OK. semi_join() is  inner_join(x, y) with columns of x only.\n- So you can see that like inner_join(), we only keep id 1 and id 2. \n- Moreover, we only keep variables id and var_x. No var_y variable in the data set.\n:::\n\n\n\n## `semi_join()` Example  {visibility=\"hidden\"}\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npop_x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       state population\n1    Alabama    4779736\n2     Alaska     710231\n3    Arizona    6392017\n4   Arkansas    2915918\n5 California   37253956\n6   Colorado    5029196\n```\n:::\n\n```{.r .cell-code}\nelec_vote_y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        state elec_vote\n1  California        55\n2     Arizona        11\n3     Alabama         9\n4 Connecticut         7\n5      Alaska         3\n6    Delaware         3\n```\n:::\n:::\n\n:::\n\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npop_x |> \n    semi_join(elec_vote_y) #<<\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       state population\n1    Alabama    4779736\n2     Alaska     710231\n3    Arizona    6392017\n4 California   37253956\n```\n:::\n:::\n\n:::\n::::\n\n::: notes\n- The result here becomes straightforward. The four states that are ion both x and y are kept and the data only keep the variables state and population in pop_x data set.\n:::\n\n\n## `anti_join(x, y)` (Opposite of `semi_join(x, y)`)  {visibility=\"hidden\"}\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/13-dplyr-2/anti-join.gif){fig-align='center' width=100% style=\"background-color: #FDF6E3\"}\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nanti_join(x, y)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(id)`\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 Ã— 2\n     id var_x\n  <dbl> <chr>\n1     3 x3   \n```\n:::\n:::\n\n- Keep the elements of first table for which there is **NO** information in the second.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/13-dplyr-2/anti_join_venn.png){fig-align='center' width=100%}\n:::\n:::\n\n:::\n::::\n\n::: notes\n- OK. finally `anti_join(x, y)`. `anti_join(x, y)` can be viewed as the opposite of `semi_join(x, y)`.\n- It keeps rows in x that do not have a match in y. In our example, it is id 3 that is kept in the output data.\n- And again, same as `anti_join(x, y)`. Only columns of x are preserved in the output. so we have var_x, but no var_y. \n:::\n\n\n## `anti_join()` Example  {visibility=\"hidden\"}\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npop_x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       state population\n1    Alabama    4779736\n2     Alaska     710231\n3    Arizona    6392017\n4   Arkansas    2915918\n5 California   37253956\n6   Colorado    5029196\n```\n:::\n\n```{.r .cell-code}\nelec_vote_y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        state elec_vote\n1  California        55\n2     Arizona        11\n3     Alabama         9\n4 Connecticut         7\n5      Alaska         3\n6    Delaware         3\n```\n:::\n:::\n\n:::\n\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npop_x |> \n    anti_join(elec_vote_y) #<<\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     state population\n1 Arkansas    2915918\n2 Colorado    5029196\n```\n:::\n:::\n\n:::\n::::\n\n::: notes\n- Here, because Arkansas and Colorado are in x, but not in y, they are kept in the anti-joined output.\n- Also state and population are the variables of pop_x.\n:::\n\n##\n::: {.lab}\n<span style=\"color:blue\"> **16-Joining tables** </span>\n\n<!-- - Create the R script **lab14-jointable.R** -->\n\nIn **lab.qmd** `## Lab 16` section\n\n- Import the data at <https://www.jaredlander.com/data/DiamondColors.csv>. Call it `diamond_color`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndiamond_color <- readr::read_csv(\"the url\")\n```\n:::\n\n\n- Use `left_join()` to combine the data set `diamonds` in **ggplot2** and `diamond_color` by the key variable `color`. \n\n<!-- We keep all the rows of `diamonds`. -->\n\n- Select the variables `carat`, `color`, `Description`, `Details`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Variable \"color\" in diamonds but \"Color\" in diamond_color\n\njoined_df <- diamonds |>  \n    _______(_______, by = c('color' = 'Color')) |>  ## join\n    _______(_________________________________________)  ## select\n```\n:::\n\n\n- Create a bar chart of the variable `color`.\n\n<!-- - Find the count of the most frequent color G. -->\n:::\n\n\n##\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 53,940 Ã— 4\n  carat color Description    Details                  \n  <dbl> <chr> <chr>          <chr>                    \n1  0.23 E     Colorless      Minute traces of color   \n2  0.21 E     Colorless      Minute traces of color   \n3  0.23 E     Colorless      Minute traces of color   \n4  0.29 I     Near Colorless Slightly detectable color\n5  0.31 J     Near Colorless Slightly detectable color\n6  0.24 J     Near Colorless Slightly detectable color\n# â„¹ 53,934 more rows\n```\n:::\n\n::: {.cell-output-display}\n![](images/13-dplyr-2/unnamed-chunk-42-1.png){fig-align='center' width=55%}\n:::\n:::\n\n\n\n# {background-color=\"#ffde57\" background-image=\"https://upload.wikimedia.org/wikipedia/commons/e/ed/Pandas_logo.svg\" background-size=\"40%\" background-position=\"90% 50%\"}\n\n\n::: {.left}\n<h1> Joining Data Frames </h1>\n\n<h2> pd.merge() </h2>\n:::\n\n## pd.merge()\n\n\n::::: {.panel-tabset}\n\n\n## Left join\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nimport numpy as np\nimport pandas as pd\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\npop_x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        state  population\n0     Alabama     4779736\n1      Alaska      710231\n2     Arizona     6392017\n3    Arkansas     2915918\n4  California    37253956\n5    Colorado     5029196\n```\n:::\n\n```{.python .cell-code}\nelec_vote_y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          state  electoral_votes\n21      Alabama                9\n43       Alaska                3\n13      Arizona               11\n0    California               55\n26  Connecticut                7\n44     Delaware                3\n```\n:::\n:::\n\n\n\n:::\n\n\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\n## dplyr::left_join()\npd.merge(pop_x, elec_vote_y, how = 'left')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        state  population  electoral_votes\n0     Alabama     4779736              9.0\n1      Alaska      710231              3.0\n2     Arizona     6392017             11.0\n3    Arkansas     2915918              NaN\n4  California    37253956             55.0\n5    Colorado     5029196              NaN\n```\n:::\n:::\n\n:::\n::::\n\n## Code for generating the data sets\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nmurders = pd.read_csv('./data/murders.csv')\npop_x = murders[0:6][['state','population']]\n\nelection = pd.read_csv('./data/results_us_election_2016.csv')\nraws1 = [\"Alabama\", \"Alaska\", \"Arizona\", \"California\", \"Connecticut\", \"Delaware\"]\ncols1 = [\"state\", \"electoral_votes\"]\ndf = election[cols1]\npop = []\nfor i in raws1:\n    mask = df[\"state\"] == i\n    pos = np.flatnonzero(mask)\n    pop.append(pos)\n\npop = np.array(pop)\npop = np.resize(pop, 6)\nelec_vote_y = df.iloc[pop]\n```\n:::\n\n:::::\n\n\n## \n\n<!-- :::{.midi} -->\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\npd.merge(pop_x, elec_vote_y, how = 'right') ## dplyr::right_join()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         state  population  electoral_votes\n0      Alabama   4779736.0                9\n1       Alaska    710231.0                3\n2      Arizona   6392017.0               11\n3   California  37253956.0               55\n4  Connecticut         NaN                7\n5     Delaware         NaN                3\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\npd.merge(pop_x, elec_vote_y, how = 'outer') ## dplyr::full_join()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         state  population  electoral_votes\n0      Alabama   4779736.0              9.0\n1       Alaska    710231.0              3.0\n2      Arizona   6392017.0             11.0\n3     Arkansas   2915918.0              NaN\n4   California  37253956.0             55.0\n5     Colorado   5029196.0              NaN\n6  Connecticut         NaN              7.0\n7     Delaware         NaN              3.0\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\npd.merge(pop_x, elec_vote_y, how = 'inner') ## dplyr::inner_join()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        state  population  electoral_votes\n0     Alabama     4779736                9\n1      Alaska      710231                3\n2     Arizona     6392017               11\n3  California    37253956               55\n```\n:::\n:::\n\n<!-- ::: -->\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}