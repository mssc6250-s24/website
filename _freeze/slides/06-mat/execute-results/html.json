{
  "hash": "670f4f30d0e6731c1183c27ec69f0181",
  "result": {
    "markdown": "---\ntitle: \"Matrix Algebra üë®‚Äçüíª\"\nsubtitle: \"MATH 4780 / MSSC 5780 Regression Analysis\"\nauthor: \"Dr. Cheng-Han Yu <br> Department of Mathematical and Statistical Sciences <br> Marquette University\"\n# date: \"August 02 2023\"\n# macros: _macros.tex # import a list of TeX/LaTeX definitions\nformat: \n  revealjs:\n    code-line-numbers: false\n    #     - \"macros.tex\"\n    html-math-method:\n      method: mathjax\n      url: \"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"\n    # include-in-header:\n    highlight-style: arrow\n    code-block-bg: true\n    self-contained: false\n    slide-number: c/t    \n    incremental: false\n    width: 1800\n    height: 1000\n    margin: 0.05\n    logo: \"https://upload.wikimedia.org/wikipedia/commons/e/e8/Marquette_Golden_Eagles_logo.svg\"\n    footer: \"[math4780-f23.github.io/website](https://math4780-f23.github.io/website/)\"\n    theme: [\"simple\", \"slides.scss\"]\n    multiplex: true\n    code-link: true\n    fig-cap-location: bottom\n    fig-align: center\n    transition: none ## fade slide convex concave zoom\n    title-slide-attributes:\n      data-background-color: \"#447099\"\n      # data-background-image: images/paper-texture.jpg\n      # data-background-size: cover\n      # data-background-color: \"#698ED5\"\neditor: source\nexecute:\n  freeze: true\n  echo: true\n  purl: true\n---\n\n\n#  {visibility=\"hidden\"}\n\n\\def\\bx{\\mathbf{x}}\n\\def\\bg{\\mathbf{g}}\n\\def\\bw{\\mathbf{w}}\n\\def\\bbeta{\\boldsymbol \\beta}\n\\def\\bsLambda{\\boldsymbol \\Lambda}\n\\def\\bX{\\mathbf{X}}\n\\def\\by{\\mathbf{y}}\n\\def\\bH{\\mathbf{H}}\n\\def\\bI{\\mathbf{I}}\n\\def\\bS{\\mathbf{S}}\n\\def\\bW{\\mathbf{W}}\n\\def\\T{\\text{T}}\n\\def\\cov{\\mathrm{Cov}}\n\\def\\cor{\\mathrm{Corr}}\n\\def\\var{\\mathrm{Var}}\n\\def\\E{\\mathrm{E}}\n\\def\\bmu{\\boldsymbol \\mu}\n\\DeclareMathOperator*{\\argmin}{arg\\,min}\n\\def\\Trace{\\text{Trace}}\n\n\n\n\n\n\n\n\n## Matrix\n- A **matrix** ${\\bf A}$ that has $n$ rows and $m$ columns is defined as $${\\bf A} = (a_{ij})_{n \\times m}\\begin{bmatrix} a_{11} & a_{12} & \\cdots & a_{1m} \\\\ a_{21} & a_{22} & \\cdots & a_{2m} \\\\ \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\ a_{n1} & a_{n2} & \\cdots & a_{nm} \\end{bmatrix}_{n \\times m}$$\n\n. . .\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n(A <- matrix(data = 1:6, \n             nrow = 2, ncol = 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n\n```{.r .cell-code}\nclass(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n:::\n\n:::\n\n\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nattributes(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$dim\n[1] 2 3\n```\n:::\n:::\n\n:::\n::::\n\n. . .\n\n::: question\nBut what is the geometrical meaning of matrices?\n:::\n\n\n::: notes\n- First index is for row and the second index is for column\n- Use command matrix() to create a matrix.\n- A matrix is a two-dimensional analog of a vector.\n- Like **all** elements of a matrix must be of the **same type.**\n:::\n\n\n\n##\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![https://gfycat.com/cooperativequerulousfirefly (3Blue1Brown)](https://thumbs.gfycat.com/CooperativeQuerulousFirefly-size_restricted.gif){fig-align='center' width=100%}\n:::\n:::\n\n\n\n::: notes\n- A matrix is actually a numerical representation of a linear transformation in a linear space which is a function that takes an vector as an input and produces another vector as an output.\n- If we use the grid lines to represent the entire coordinate system, we will see that when we use (1, 0) and (0, 1) as the two bases, all lines are vertical and horizontal, showing, for example, the integer values of each coordinate. \n- Linear transformation means we stretch or rotate the lines, but at the same time, all lines remains lines and origin remain fixed.\n- Grids lines are parallel and evenly spaced after linear transformation.\n- (-1, 3) is the transformed vector of (-1, 2) when the two new transformed basis are (3, 1) and (1, 2)\n:::\n\n\n## Column Vector\n- If $m = 1$, it becomes a $n$ by 1 matrix or a **column vector** of size $n$.\n$$\\small {\\bf y} = \\begin{bmatrix} y_{1}  \\\\ y_{2}  \\\\ \\vdots  \\\\  y_{n} \\end{bmatrix}_{n \\times 1} \\quad {\\bf 1} = \\begin{bmatrix} 1  \\\\ 1  \\\\ \\vdots  \\\\  1 \\end{bmatrix}_{n \\times 1}$$\n\n. . .\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n\n```{.r .cell-code}\n## 2nd column\nA[, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 4\n```\n:::\n\n```{.r .cell-code}\n## becomes a numeric vector\nclass(A[, 2]) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n:::\n\n\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## keep its matrix class\nA[, 2, drop = FALSE] \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,]    3\n[2,]    4\n```\n:::\n\n```{.r .cell-code}\nclass(A[, 2, drop = FALSE])  \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n:::\n\n:::\n::::\n\n\n\n\n## Row Vector\n- If $n = 1$, it becomes a $1$ by $m$ matrix or a **row vector** of size $m$.\n$${\\bf x} = \\begin{bmatrix} x_{1} &  x_{2}  & \\dots  &  x_{m} \\end{bmatrix}_{1 \\times m}$$\n- By default, a vector means a *column* vector.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## 2nd row\nA[2, , drop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    2    4    6\n```\n:::\n\n```{.r .cell-code}\n## keep its matrix class\nclass(A[2, , drop = FALSE]) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n:::\n\n\n## Transpose\n- Let ${\\bf A}$ be an $n \\times m$ matrix. The transpose of ${\\bf A}$, denoted by ${\\bf A}'$ or ${\\bf A}^T$, is a $m \\times n$ matrix whose columns are the rows of ${\\bf A}$.\n$${\\bf A} = \\begin{bmatrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ \\end{bmatrix} \\quad {\\bf A}' =\\begin{bmatrix} 1 & 4 \\\\ 2 & 5 \\\\ 3 & 6\\end{bmatrix}$$\n$${\\bf X}_{n \\times 2}\\begin{bmatrix} 1 & x_1 \\\\ 1 & x_{2} \\\\ \\vdots  & \\vdots  \\\\ 1 & x_n \\end{bmatrix} = \\begin{bmatrix} {\\bf 1} & {\\bf x} \\end{bmatrix}$$\n$${\\bf X}'_{2 \\times n} = \\begin{bmatrix} 1 & 1 & \\cdots & 1 \\\\ x_1 & x_2 & \\cdots & x_n \\end{bmatrix} = \\begin{bmatrix} {\\bf 1}' \\\\ {\\bf x}' \\end{bmatrix}$$\n\n\n## Transpose in R\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n\n```{.r .cell-code}\nt(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]    5    6\n```\n:::\n:::\n\n\n## Linear Independence\n<!-- - Vectors ${\\bf v}_1, {\\bf v}_2, \\dots, {\\bf v}_k$ is said to be **linearly dependent** if there exists scalars $c_{1},c_{2},\\dots,c_{k},$ not all zero, such that  -->\n<!-- $$c_{1}{\\bf v}_1 + c_{2}{\\bf v}_2 + \\cdots + c_{k}{\\bf v}_k = \\bf 0$$ -->\n- Vectors ${\\bf v}_1, {\\bf v}_2, \\dots, {\\bf v}_k$ is said to be **linearly independent** if for scalars $c_{1},c_{2},\\dots,c_{k} \\in \\mathbf{R},$\n$$c_{1}{\\bf v}_1 + c_{2}{\\bf v}_2 + \\cdots + c_{k}{\\bf v}_k = \\bf 0$$ can only be satisfied by $c_i = 0$ for all $i = 1, 2, \\dots, k$.\n\n::: question\nAre ${\\bf v}_1 = (1, 1)'$ and ${\\bf v}_2 = (-3, 2)'$ linearly independent?\n:::\n\n. . .\n\nWays to check linear independence:\n\n- solve the homogeneous linear system\n$\\begin{bmatrix} 1 & -3 \\\\ 1 & 2 \\end{bmatrix}\\begin{bmatrix} c_1 \\\\ c_2 \\end{bmatrix}=\\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$ for $c_1$ and $c_2$.\n\n- check if $\\text{det} \\left( \\begin{bmatrix} 1 & -3 \\\\ 1 & 2 \\end{bmatrix} \\right)$ is non-zero.\n\n\n\n## Linear Independence\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nV <- matrix(c(1, 1, -3, 2), 2, 2)\nsolve(V, b = rep(0, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 0\n```\n:::\n\n```{.r .cell-code}\ndet(V)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n\n::: notes\n- A is invertible, that is, A has an inverse, is nonsingular, and is nondegenerate.\n- A is row-equivalent to the n-by-n identity matrix In.\n- A is column-equivalent to the n-by-n identity matrix In.\n- A has n pivot positions.\n- A has full rank; that is, rank A = n.\n- Based on the rank A=n, the equation Ax = 0 has only the trivial solution x = 0. and the equation Ax = b has exactly one solution for each b in Kn.\n- The kernel (null space) of A is trivial\n- The columns of A are linearly independent.\n- The columns of A span Kn.\n- The columns of A form a basis of Kn.\n- det A ‚â† 0.\n- The number 0 is not an eigenvalue of A.\n- The transpose AT is an invertible matrix \n:::\n\n\n\n##  Rank\n- The **rank** of a matrix ${\\bf A} = \\begin{bmatrix} {\\bf a}_1 & {\\bf a}_2 & \\cdots & {\\bf a}_m \\end{bmatrix}$ is the *number of linearly independent columns* (dimension of the column space).\n\n- If $k$ of the $m$ column vectors ${\\bf a}_1, {\\bf a}_2, \\dots, {\\bf a}_m$ are linearly independent, the rank of ${\\bf A}$ is $k$. \n\n- The remaining $m-k$ columns of ${\\bf A}$ can be written as a linear combination of the $k$ linearly independent columns.\n\n\n::: notes\n- If $k = m$, it is full rank\n- If $k$ of the $n$ column vectors ${\\bf a}_1, {\\bf a}_2, \\dots, {\\bf a}_n$ are linearly independent, the rank of ${\\bf A}$ is $k$. The remaining $n-k$ columns can be written as a linear combination of the $k$ columns.\n- The vectors ${\\bf v}_1, {\\bf v}_2, \\dots, {\\bf v}_k$ is said to be **linearly dependent** if there exist scalars $c_{1},c_{2},\\dots,c_{k},$ not all zero, such that \n$$c_{1}{\\bf v}_1 + c_{2}{\\bf v}_2 + \\cdots + c_{k}{\\bf v}_k = \\bf 0$$\n- The column vectors ${\\bf v}_1, {\\bf v}_2, \\dots, {\\bf v}_k$ is said to be **linearly independent** if it is not linearly dependent, that is, if\n$$c_{1}{\\bf v}_1 + c_{2}{\\bf v}_2 + \\cdots + c_{k}{\\bf v}_k = \\bf 0$$ can only be satisfied by $c_i = 0, i = 1, 2, \\dots, k.$\n:::\n\n\n\n## Rank\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n(M <- matrix(1:9, nrow = 3, ncol = 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n:::\n\n```{.r .cell-code}\n# install.packages(\"Matrix\")\nlibrary(Matrix)\nrankMatrix(M)[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\n::: question\nCan you see why the rank is 2, meaning that one column can be written as a linear combo of the other two?\n:::\n\n. . .\n\n- ${\\bf a}_3 = 2{\\bf a_2}-{\\bf a}_1$\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n2 * M[, 2] - 1 * M[, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7 8 9\n```\n:::\n:::\n\n\n::: notes\n- Find the row or column basis of A using reduced row echelon form\n- the dimension of the vector space generated (or spanned) by its columns\n- dimension: number of basis in the vector space.\n:::\n\n\n## Operations: Addition\n\n- **Addition:** ${\\bf A + B}$ is adding the corresponding elements together $a_{ij} + b_{ij}$. \n\n- ${\\bf A}$ and ${\\bf B}$ must have an *equal* number of rows and columns.\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n\n```{.r .cell-code}\n(B <- matrix(6:1, nrow = 2, ncol = 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    6    4    2\n[2,]    5    3    1\n```\n:::\n\n```{.r .cell-code}\nA + B\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    7    7    7\n[2,]    7    7    7\n```\n:::\n:::\n\n\n:::\n\n\n::: {.column width=\"50%\"}\n\n::: fragment\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n(B <- matrix(1:4, nrow = 2, ncol = 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n:::\n\n```{.r .cell-code}\nA + B\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in A + B: non-conformable arrays\n```\n:::\n:::\n\n\n:::\n\n:::\n::::\n\n\n## Operations: Multiplication\n- **Multiplication:** The product of matrices ${\\bf A}$ and ${\\bf B}$ is denoted as ${\\bf AB}$.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](https://upload.wikimedia.org/wikipedia/commons/1/18/Matrix_multiplication_qtl1.svg){fig-align='center' width=55%}\n:::\n:::\n\n\n- The number of columns in ${\\bf A}$ must be equal to the number of rows ${\\bf B}$. \n- The result matrix ${\\bf C}$ has the number of rows of ${\\bf A}$ and the number of columns of the ${\\bf B}$.\n\n\n::: notes\n- The number of columns in the first matrix ${\\bf A}$ must be equal to the number of rows in the second matrix of ${\\bf B}$. \n- The resulting matrix ${\\bf C}$ has dimension of the number of rows of the first and the number of columns of the second matrix.\n:::\n\n\n## Operations: Multiplication\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n\n```{.r .cell-code}\n(B <- matrix(1:12, nrow = 3, ncol = 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n```\n:::\n:::\n\n:::\n\n\n::: {.column width=\"50%\"}\n\n::: fragment\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n(C <- A %*% B)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]   22   49   76  103\n[2,]   28   64  100  136\n```\n:::\n\n```{.r .cell-code}\n(B <- matrix(1:8, nrow = 2, ncol = 4))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n```\n:::\n\n```{.r .cell-code}\nA %*% B\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in A %*% B: non-conformable arguments\n```\n:::\n:::\n\n:::\n\n:::\n::::\n\n\n\n## Operations: Multiplication\n\n- ${\\bf A}{\\bf B} \\ne {\\bf B}{\\bf A}$ in general.\n\n- $({\\bf A}{\\bf B})' =  {\\bf B}'{\\bf A}'$.\n\n<br>\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n(C <- matrix(1:4, 2, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n:::\n\n```{.r .cell-code}\n(D <- matrix(2:5, 2, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    2    4\n[2,]    3    5\n```\n:::\n\n```{.r .cell-code}\nC %*% D\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   11   19\n[2,]   16   28\n```\n:::\n:::\n\n\n:::\n\n\n::: {.column width=\"50%\"}\n\n::: fragment\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nD %*% C\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   10   22\n[2,]   13   29\n```\n:::\n\n```{.r .cell-code}\nt(C %*% D)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   11   16\n[2,]   19   28\n```\n:::\n\n```{.r .cell-code}\nt(D) %*% t(C)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   11   16\n[2,]   19   28\n```\n:::\n:::\n\n:::\n\n:::\n\n::::\n\n\n\n## Special Matrices: Symmetric and Identity\n- A square matrix $(m = n)$ ${\\bf A}_{n \\times n}$ is a **symmetric** matrix if ${\\bf A = A}'$.\n\n$${\\bf A} = \\begin{bmatrix} 1 & 2  \\\\ 2 & 5 \\\\ \\end{bmatrix} \\quad {\\bf A}' =\\begin{bmatrix} 1 & 2 \\\\ 2 & 5 \\end{bmatrix}$$\n\n\n- A square matrix ${\\bf I}_{n \\times n}$ whose diagonal elements are 1's and off diagonal elements are 0's is called an **identity** matrix of order $n$.\n$${\\bf I} = \\begin{bmatrix} 1 & 0 & \\cdots & 0 \\\\ 0 & 1 & \\cdots & 0 \\\\ \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\ 0 & 0 & \\cdots & 1 \\end{bmatrix}$$\n\n\n::: notes\n- If the inverse exists, it is unique.\n:::\n\n\n\n## Identity and Diagonal Matrix\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Identity matrix\nI <- diag(5)\nI\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    0    0    0    0\n[2,]    0    1    0    0    0\n[3,]    0    0    1    0    0\n[4,]    0    0    0    1    0\n[5,]    0    0    0    0    1\n```\n:::\n\n```{.r .cell-code}\n## A diagonal matrix\ndiag(c(4, 2, 5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    4    0    0\n[2,]    0    2    0\n[3,]    0    0    5\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Extract diagonal elements\nD <- matrix(1:4, 2, 2)\nD\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n:::\n\n```{.r .cell-code}\ndiag(D)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 4\n```\n:::\n:::\n\n:::\n::::\n\n\n\n## Inverse Matrix\n- The **inverse** of a square matrix ${\\bf A}$, denoted by ${\\bf A}^{-1}$, is a square matrix such that $${\\bf A}^{-1}{\\bf A} = {\\bf A}{\\bf A}^{-1} = {\\bf I}$$\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nD\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n:::\n\n```{.r .cell-code}\nD_inv <- solve(D)\nD_inv\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   -2  1.5\n[2,]    1 -0.5\n```\n:::\n:::\n\n:::\n\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nD_inv %*% D\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n```\n:::\n\n```{.r .cell-code}\nD %*% D_inv\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n```\n:::\n:::\n\n:::\n::::\n\n\n\n## Idempotent, Orthogonal, Positive Definite\n- A square matrix ${\\bf A}$ is **idempotent** if ${\\bf A}{\\bf A} = {\\bf A}$.\n- A square matrix ${\\bf A}$ is **orthogonal** if ${\\bf A}^{-1} = {\\bf A}'$ and hence ${\\bf A}'{\\bf A} = {\\bf I}$.\n\n. . .\n\n- Let ${\\bf A}$ be a $n \\times n$ matrix and ${\\bf y}$ be a $n \\times 1$ vector. $${\\bf y}'{\\bf A} {\\bf y} = \\sum_{i=1}^n\\sum_{j=1}^na_{ij}y_iy_j$$ is called a **quadratic form** of ${\\bf y}$.\n\n. . .\n\n- A symmetric matrix ${\\bf A}$ is said to be \n  <!-- + ${\\bf A}' = {\\bf A}$ -->\n  + **positive definite** if ${\\bf y}'{\\bf A} {\\bf y} > 0$ for all ${\\bf y \\ne 0}$.\n  + **positive semi-definite** if ${\\bf y}'{\\bf A} {\\bf y} \\ge 0$ for all ${\\bf y \\ne 0}$ and ${\\bf y}'{\\bf A} {\\bf y} = 0$ for some ${\\bf y \\ne 0}$.\n- If ${\\bf A}$ is symmetric and idempotent, then ${\\bf A}$ is positive semi-definite.\n\n::: notes\n- How about negative definite\n:::\n\n\n## Special Matrices: Idempotent, Orthogonal\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Idempotent and symmetric matrix\n(A <- matrix(1, 3, 3)/3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,] 0.33 0.33 0.33\n[2,] 0.33 0.33 0.33\n[3,] 0.33 0.33 0.33\n```\n:::\n\n```{.r .cell-code}\nA %*% A\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,] 0.33 0.33 0.33\n[2,] 0.33 0.33 0.33\n[3,] 0.33 0.33 0.33\n```\n:::\n\n```{.r .cell-code}\n## positive semi-definite\ny <- c(-2, 5, 2)\nt(y) %*% A %*% y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,]  8.3\n```\n:::\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## Orthogonal matrix\n(E <- matrix(c(1, -1, 1, 1)/sqrt(2), 2, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2]\n[1,]  0.71 0.71\n[2,] -0.71 0.71\n```\n:::\n\n```{.r .cell-code}\nE %*% t(E)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        [,1]    [,2]\n[1,] 1.0e+00 2.2e-17\n[2,] 2.2e-17 1.0e+00\n```\n:::\n\n```{.r .cell-code}\nt(E) %*% E\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         [,1]     [,2]\n[1,]  1.0e+00 -2.2e-17\n[2,] -2.2e-17  1.0e+00\n```\n:::\n:::\n\n:::\n::::\n\n\n\n## Trace\n- The **trace** of ${\\bf A}_{n \\times n}$, denoted by $\\text{tr}({\\bf A})$, is defined as $$\\text{tr}({\\bf A}) = a_{11} + a_{22} + \\dots + a_{nn}$$\n\n- $\\text{tr}({\\bf A}{\\bf B}) = \\text{tr}({\\bf B}{\\bf A})$\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n(G <- matrix(1:9, 3, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n:::\n\n```{.r .cell-code}\nsum(diag(G))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15\n```\n:::\n:::\n\n\n\n\n## Eigenvalues and Eigenvectors\n\n- For a square matrix ${\\bf A}$, if we can find a scalar $\\lambda$ and a non-zero vector ${\\bf x}$ such that $${\\bf Ax} = \\lambda {\\bf x},$$\n  + $\\lambda$ is an **eigenvalue** of ${\\bf A}$\n  + ${\\bf x}$ is a corresponding **eigenvector** of ${\\bf A}$.\n\n- A $n \\times n$ matrix ${\\bf A}$ will have $n$ eigenvalues and $n$ corresponding eigenvectors.\n\n\n\n\n##\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![https://gfycat.com/ifr/WickedSaltyAnemonecrab (3Blue1Brown)](https://thumbs.gfycat.com/WickedSaltyAnemonecrab-size_restricted.gif){fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n## Eigen-decomposition\n- **Eigen-decomposition**: Any symmetric matrix ${\\bf A}_{n \\times n}$ can be decomposed as $${\\bf A} = {\\bf V\\bsLambda V'}$$\n\n- $\\bsLambda$ is a $n \\times n$ diagnonal matrix whose elements are eigenvalues $\\lambda_j$ of ${\\bf A}$\n  $$\\bsLambda = \\begin{bmatrix} \\lambda_1 & 0 & \\cdots & 0 \\\\ 0 & \\lambda_2 & \\cdots & 0 \\\\ \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\ 0 & 0 & \\cdots & \\lambda_n \\end{bmatrix}$$\n  \n- ${\\bf V} = [{\\bf v}_1 \\quad {\\bf v}_2 \\quad \\dots \\quad {\\bf v}_n]$ is a $n \\times n$ orthogonal matrix whose columns are the eigenvectors of ${\\bf A}.$\n\n\n\n## Eigenvalues and Eigenvectors\n\n- $\\text{tr}({\\bf A}) = \\sum_{i=1}^n\\lambda_i$\n- $|{\\bf A}| = \\prod_{i=1}^n \\lambda_i$\n- $\\text{rank}({\\bf A}) =$ the number of non-zero $\\lambda_i$\n- If ${\\bf A}$ is symmetric, all $\\lambda_i \\in \\mathbf{R}$\n\n\n\n## Eigenvalues and Eigenvectors\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n(A <- matrix(c(3, 1, 1, 2), 2, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    3    1\n[2,]    1    2\n```\n:::\n\n```{.r .cell-code}\neigen_decomp <- eigen(A)\n(lam <- eigen_decomp$values)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.6 1.4\n```\n:::\n\n```{.r .cell-code}\n(V <- eigen_decomp$vectors)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]  [,2]\n[1,] -0.85  0.53\n[2,] -0.53 -0.85\n```\n:::\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nV %*% diag(lam) %*% t(V)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    3    1\n[2,]    1    2\n```\n:::\n\n```{.r .cell-code}\nsum(diag(A))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nsum(lam)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\ndet(A)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nprod(lam)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n:::\n::::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}